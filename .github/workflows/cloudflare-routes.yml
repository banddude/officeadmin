name: Auto-manage Cloudflare Routes

on:
  push:
    branches: [ main ]
    paths:
      - '*/index.html'  # Trigger when new page directories are added
  workflow_dispatch:     # Allow manual triggers

env:
  CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
  CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
  CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

jobs:
  manage-routes:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 2  # Get current and previous commit for diff

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install dependencies
      run: npm install axios

    - name: Update Worker and Manage Cloudflare Routes
      run: |
        cat << 'EOF' > manage-routes.js
        const axios = require('axios');
        const fs = require('fs');
        const path = require('path');

        // Protected routes - these cannot be used for GitHub Pages
        const PROTECTED_ROUTES = [
          '/signin',
          '/workflows', 
          '/executions',
          '/credentials',
          '/settings',
          '/webhook',
          '/api',
          '/home',
          '/rest',
          '/assets',
          '/static'
        ];

        const CLOUDFLARE_API_TOKEN = process.env.CLOUDFLARE_API_TOKEN;
        const CLOUDFLARE_ZONE_ID = process.env.CLOUDFLARE_ZONE_ID;
        const CLOUDFLARE_ACCOUNT_ID = process.env.CLOUDFLARE_ACCOUNT_ID;

        if (!CLOUDFLARE_API_TOKEN || !CLOUDFLARE_ZONE_ID || !CLOUDFLARE_ACCOUNT_ID) {
          console.error('‚ùå Missing required environment variables');
          process.exit(1);
        }

        async function getExistingRoutes() {
          try {
            const response = await axios.get(
              `https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/workers/routes`,
              {
                headers: {
                  'Authorization': `Bearer ${CLOUDFLARE_API_TOKEN}`,
                  'Content-Type': 'application/json'
                }
              }
            );
            return response.data.result.map(route => route.pattern);
          } catch (error) {
            console.error('‚ùå Error fetching existing routes:', error.message);
            process.exit(1);
          }
        }

        async function createRoute(pattern) {
          try {
            const response = await axios.post(
              `https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/workers/routes`,
              {
                pattern: pattern,
                script: 'officeadmin-router'
              },
              {
                headers: {
                  'Authorization': `Bearer ${CLOUDFLARE_API_TOKEN}`,
                  'Content-Type': 'application/json'
                }
              }
            );
            console.log(`‚úÖ Created route: ${pattern}`);
            return response.data.success;
          } catch (error) {
            console.error(`‚ùå Error creating route ${pattern}:`, error.message);
            return false;
          }
        }

        function findNewPages() {
          const pages = [];
          
          // Find all directories with index.html files
          function scanDirectory(dir, basePath = '') {
            const items = fs.readdirSync(dir);
            
            for (const item of items) {
              const fullPath = path.join(dir, item);
              const relativePath = path.join(basePath, item);
              
              if (fs.statSync(fullPath).isDirectory()) {
                // Skip hidden directories and special directories
                if (item.startsWith('.') || item === 'node_modules') {
                  continue;
                }
                
                // Check if this directory has an index.html
                const indexPath = path.join(fullPath, 'index.html');
                if (fs.existsSync(indexPath)) {
                  const routePath = '/' + relativePath.replace(/\\\\/g, '/');
                  pages.push(routePath);
                }
                
                // Recursively scan subdirectories
                scanDirectory(fullPath, relativePath);
              }
            }
          }
          
          scanDirectory('.');
          
          // Filter out root path (handled differently)
          return pages.filter(page => page !== '/');
        }

        async function updateWorkerCode(pages) {
          console.log('üîß Updating worker code with new pages...');
          
          try {
            // Read the current worker from cloudflare branch
            const { execSync } = require('child_process');
            
            // Switch to cloudflare branch and get worker
            execSync('git fetch origin cloudflare', { stdio: 'inherit' });
            execSync('git checkout cloudflare', { stdio: 'inherit' });
            
            let workerCode = fs.readFileSync('worker.js', 'utf8');
            
            // Create the new paths array including root and all found pages
            const allPaths = ['/'].concat(pages);
            const pathsArray = allPaths.map(p => `  '${p}'`).join(',\\n');
            
            // Update the GITHUB_PAGES_PATHS array
            const pathsRegex = /(const GITHUB_PAGES_PATHS = \[)[\s\S]*?(\];)/;
            const newPathsSection = 'const GITHUB_PAGES_PATHS = [\\n' + pathsArray + '\\n];';
            
            workerCode = workerCode.replace(pathsRegex, newPathsSection);
            
            // Write the updated worker code
            fs.writeFileSync('worker.js', workerCode);
            
            // Deploy the updated worker
            const deployResponse = await axios.put(
              `https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/workers/scripts/officeadmin-router`,
              workerCode,
              {
                headers: {
                  'Authorization': `Bearer ${CLOUDFLARE_API_TOKEN}`,
                  'Content-Type': 'application/javascript'
                }
              }
            );
            
            if (deployResponse.data.success) {
              console.log('‚úÖ Worker updated and deployed successfully');
              
              // Commit the updated worker
              execSync('git add worker.js', { stdio: 'inherit' });
              execSync(`git commit -m "Auto-update worker paths: ${pages.join(', ')}"`, { stdio: 'inherit' });
              execSync('git push origin cloudflare', { stdio: 'inherit' });
              
              return true;
            } else {
              console.error('‚ùå Failed to deploy updated worker:', deployResponse.data.errors);
              return false;
            }
          } catch (error) {
            console.error('‚ùå Error updating worker:', error.message);
            return false;
          }
        }

        async function main() {
          console.log('üîç Scanning for GitHub Pages...');
          
          const newPages = findNewPages();
          console.log('üìÑ Found pages:', newPages);
          
          if (newPages.length === 0) {
            console.log('‚ú® No new pages found');
            return;
          }
          
          // Check for protected route conflicts
          const conflicts = newPages.filter(page => 
            PROTECTED_ROUTES.some(protected => 
              page === protected || page.startsWith(protected + '/')
            )
          );
          
          if (conflicts.length > 0) {
            console.error('üö´ ROUTE CONFLICT DETECTED!');
            console.error('The following paths conflict with n8n routes:');
            conflicts.forEach(conflict => console.error(`  - ${conflict}`));
            console.error('\\nProtected routes:');
            PROTECTED_ROUTES.forEach(route => console.error(`  - ${route}`));
            console.error('\\n‚ùå Build failed to prevent n8n conflicts');
            process.exit(1);
          }
          
          // Get existing routes to avoid duplicates
          console.log('üìã Checking existing Cloudflare routes...');
          const existingRoutes = await getExistingRoutes();
          
          let routesCreated = 0;
          
          for (const page of newPages) {
            const routePattern = `officeadmin.io${page}/*`;
            
            if (existingRoutes.includes(routePattern)) {
              console.log(`‚è≠Ô∏è  Route already exists: ${routePattern}`);
              continue;
            }
            
            console.log(`üöÄ Creating route: ${routePattern}`);
            const success = await createRoute(routePattern);
            if (success) {
              routesCreated++;
            }
          }
          
          // Update worker code with all found pages
          const workerUpdated = await updateWorkerCode(newPages);
          
          if (routesCreated > 0 || workerUpdated) {
            console.log(`\\n‚úÖ Successfully created ${routesCreated} Cloudflare routes`);
            if (workerUpdated) {
              console.log('‚úÖ Worker code updated and deployed');
            }
            console.log('üéâ Your new pages are now accessible!');
          } else {
            console.log('\\n‚ú® All routes already exist and worker is up to date');
          }
        }

        main().catch(error => {
          console.error('‚ùå Script failed:', error);
          process.exit(1);
        });
        EOF

        node manage-routes.js

    - name: Action completed
      run: echo "‚úÖ Cloudflare routes management completed"